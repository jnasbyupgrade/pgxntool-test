#!/usr/bin/env bats

# Test: pg_tle support (sequential)
#
# Tests that pg_tle registration SQL generation works correctly:
# - Script exists and is executable
# - make pgtle creates pg_tle directory
# - Generates both version files by default
# - PGTLE_VERSION limits output to specific version
# - Version-specific schema parameter handling
# - All versions and upgrade paths included
# - Control file fields properly parsed
# - Works with and without requires field
# - Error handling for missing files
# - Make dependencies trigger rebuilds
#
# This is a sequential test that runs after 03-setup-final

load ../lib/helpers

setup_file() {
  debug 1 ">>> ENTER setup_file: 04-pgtle (PID=$$)"
  setup_sequential_test "04-pgtle" "03-setup-final"
  debug 1 "<<< EXIT setup_file: 04-pgtle (PID=$$)"
}

setup() {
  load_test_env "sequential"
  cd "$TEST_REPO"
}

teardown_file() {
  debug 1 ">>> ENTER teardown_file: 04-pgtle (PID=$$)"
  mark_test_complete "04-pgtle"
  debug 1 "<<< EXIT teardown_file: 04-pgtle (PID=$$)"
}

@test "pgtle: script exists and is executable" {
  [ -x "$TEST_REPO/pgxntool/pgtle.sh" ]
}

@test "pgtle: make pgtle creates pg_tle directory" {
  run make pgtle
  assert_success
  [ -d "pg_tle" ]
}

@test "pgtle: generates all three version files by default" {
  # Files already generated by previous test
  [ -f "pg_tle/1.0.0-1.4.0/pgxntool-test.sql" ]
  [ -f "pg_tle/1.4.0-1.5.0/pgxntool-test.sql" ]
  [ -f "pg_tle/1.5.0+/pgxntool-test.sql" ]
}

@test "pgtle: --pgtle-version limits output to specific version" {
  # Note: The Makefile always generates all versions. This test verifies
  # that the script's --pgtle-version flag works correctly when called directly.
  run rm -rf pg_tle
  assert_success

  run "$TEST_REPO/pgxntool/pgtle.sh" --extension pgxntool-test --pgtle-version 1.5.0+
  assert_success

  [ -f "pg_tle/1.5.0+/pgxntool-test.sql" ]
  [ ! -f "pg_tle/1.0.0-1.4.0/pgxntool-test.sql" ]
  [ ! -f "pg_tle/1.4.0-1.5.0/pgxntool-test.sql" ]
}

@test "pgtle: 1.0.0-1.4.0 file does not have schema parameter" {
  # Previous test only generated 1.5.0+, so regenerate all files
  run make pgtle
  assert_success
  # Verify install_extension calls do NOT have schema parameter
  # Count install_extension calls
  local count=$(grep -c "pgtle.install_extension" pg_tle/1.0.0-1.4.0/pgxntool-test.sql || echo "0")
  [ "$count" -gt 0 ]
  # Verify no schema parameter (should end with NULL or ARRAY[...] before closing paren)
  ! grep -q "schema parameter" pg_tle/1.0.0-1.4.0/pgxntool-test.sql
}

@test "pgtle: 1.4.0-1.5.0 file does not have schema parameter" {
  # File already generated by previous test
  # Verify install_extension calls do NOT have schema parameter
  # Count install_extension calls
  local count=$(grep -c "pgtle.install_extension" pg_tle/1.4.0-1.5.0/pgxntool-test.sql || echo "0")
  [ "$count" -gt 0 ]
  # Verify no schema parameter (should end with NULL or ARRAY[...] before closing paren)
  ! grep -q "schema parameter" pg_tle/1.4.0-1.5.0/pgxntool-test.sql
}

@test "pgtle: 1.5.0+ file has schema parameter" {
  # File already generated by previous test
  # Verify install_extension calls DO have schema parameter
  grep -q "schema parameter" pg_tle/1.5.0+/pgxntool-test.sql
}

@test "pgtle: delimiter not present in source SQL files" {
  ! grep -r '$_pgtle_wrap_delimiter_$' sql/ || true
}

@test "pgtle: all versions included in output file" {
  # Template has both 0.1.0 and 0.1.1 version files committed
  # File already generated by previous test
  # Should have at least 2 versions (0.1.0 and 0.1.1)
  local count=$(grep -c "pgtle.install_extension\|pgtle.install_extension_version_sql" pg_tle/1.5.0+/pgxntool-test.sql || echo "0")
  [ "$count" -ge 2 ]
}

@test "pgtle: upgrade paths included in output" {
  # File already generated by previous test
  grep -q "pgtle.install_update_path" pg_tle/1.5.0+/pgxntool-test.sql
}

@test "pgtle: control file comment becomes description" {
  # File already generated by previous test
  local comment=$(grep "^comment" pgxntool-test.control | sed "s/comment = '\(.*\)'/\1/" | sed "s/comment = \"\(.*\)\"/\1/")
  grep -qF "$comment" pg_tle/1.5.0+/pgxntool-test.sql
}

@test "pgtle: works without requires field" {
  # Remove requires if present
  if grep -q "^requires" pgxntool-test.control; then
    sed -i.bak '/^requires/d' pgxntool-test.control
    rm -f pgxntool-test.control.bak
  fi
  
  # Makefile should detect control file change and rebuild automatically
  make pgtle
  # Should generate successfully without requires
  [ -f "pg_tle/1.5.0+/pgxntool-test.sql" ]
  # Should use NULL instead of ARRAY when requires is missing
  grep -q "NULL" pg_tle/1.5.0+/pgxntool-test.sql
  ! grep -q "ARRAY\[" pg_tle/1.5.0+/pgxntool-test.sql || true
}

@test "pgtle: requires field becomes ARRAY when present" {
  # Ensure requires field is present (test 11 may have removed it)
  if ! grep -q "^requires" pgxntool-test.control; then
    echo "requires = 'plpgsql'" >> pgxntool-test.control
  fi
  
  # Verify control file is in Makefile dependencies
  # Use make print-VARIABLE to debug Makefile variable values
  run make print-PGXNTOOL_CONTROL_FILES
  assert_success
  assert_contains "pgxntool-test.control"
  
  # Sleep and touch to ensure make detects the control file change
  # Why sleeps are needed:
  # 1. Make uses file modification timestamps to determine if targets need rebuilding
  # 2. Filesystem timestamp granularity can be 1-2 seconds on some systems
  # 3. Test 11 just generated the output file, so we need to ensure enough time has passed
  # 4. We sleep 2 seconds first, then touch the control file, then sleep 1 more second
  #    to ensure the control file timestamp is definitely newer than the output file
  sleep 2
  touch pgxntool-test.control
  sleep 1
  
  # Makefile should detect control file change and rebuild automatically
  make pgtle
  grep -q "ARRAY\[" pg_tle/1.5.0+/pgxntool-test.sql
}

@test "pgtle: set_default_version included" {
  # File already generated by previous test
  grep -q "pgtle.set_default_version" pg_tle/1.5.0+/pgxntool-test.sql
}

@test "pgtle: BEGIN/COMMIT transaction wrapper" {
  # File already generated by previous test
  local file="pg_tle/1.5.0+/pgxntool-test.sql"

  # Verify BEGIN exists and COMMIT exists
  grep -q "^BEGIN;" "$file"
  grep -q "^COMMIT;" "$file"

  # Verify BEGIN is the first command (first non-comment, non-blank line)
  # Skip single-line comments (--), multi-line comment markers (/* and */), and comment content lines ( *)
  local first_command=$(grep -v '^--' "$file" | grep -v '^[[:space:]]*$' | grep -v '^/\*' | grep -v '^ \*' | grep -v '^\*/' | head -1)
  [ "$first_command" = "BEGIN;" ]

  # Verify COMMIT is the last command (last non-blank line)
  local last_line=$(grep -v '^[[:space:]]*$' "$file" | tail -1)
  [ "$last_line" = "COMMIT;" ]
}

@test "pgtle: make clean removes pg_tle directory" {
  make pgtle
  [ -d "pg_tle" ]
  make clean
  [ ! -d "pg_tle" ]
}

@test "pgtle: control file change triggers rebuild" {
  make pgtle
  local mtime1=$(stat -f %m pg_tle/1.5.0+/pgxntool-test.sql 2>/dev/null || stat -c %Y pg_tle/1.5.0+/pgxntool-test.sql)
  sleep 1
  touch pgxntool-test.control
  make pgtle
  local mtime2=$(stat -f %m pg_tle/1.5.0+/pgxntool-test.sql 2>/dev/null || stat -c %Y pg_tle/1.5.0+/pgxntool-test.sql)
  [ "$mtime2" -gt "$mtime1" ]
}

@test "pgtle: SQL file change triggers rebuild" {
  make pgtle
  local mtime1=$(stat -f %m pg_tle/1.5.0+/pgxntool-test.sql 2>/dev/null || stat -c %Y pg_tle/1.5.0+/pgxntool-test.sql)
  sleep 1
  touch sql/pgxntool-test--0.1.0.sql
  make pgtle
  local mtime2=$(stat -f %m pg_tle/1.5.0+/pgxntool-test.sql 2>/dev/null || stat -c %Y pg_tle/1.5.0+/pgxntool-test.sql)
  [ "$mtime2" -gt "$mtime1" ]
}

@test "pgtle: error on missing control file" {
  run "$TEST_REPO/pgxntool/pgtle.sh" --extension nonexistent --pgtle-version 1.5.0+
  assert_failure
  assert_contains "Control file not found"
}

@test "pgtle: error on no versioned SQL files" {
  # Create a temporary extension with no SQL files
  echo "default_version = '1.0'" > empty.control
  run "$TEST_REPO/pgxntool/pgtle.sh" --extension empty --pgtle-version 1.5.0+
  assert_failure
  assert_contains "No versioned SQL files found"
  rm -f empty.control
}

@test "pgtle: warning on module_pathname in control" {
  # Create a C extension control file
  echo "comment = 'C extension'" > cext.control
  echo "default_version = '1.0'" >> cext.control
  echo "module_pathname = '\$libdir/cext'" >> cext.control
  echo "SELECT 1;" > sql/cext--1.0.sql

  run "$TEST_REPO/pgxntool/pgtle.sh" --extension cext --pgtle-version 1.5.0+
  # Should succeed but warn
  assert_success
  assert_contains "WARNING.*module_pathname"
  assert_contains "C code"

  # Cleanup
  rm -f cext.control sql/cext--1.0.sql
}

# Helper function to test internal pgtle.sh functions
call_pgtle_function() {
  local func_name="$1"
  shift
  "$TEST_REPO/pgxntool/pgtle.sh" --test-function "$func_name" "$@"
}

@test "pgtle: parse_version handles numeric versions" {
  # Standard semantic version
  run call_pgtle_function parse_version "1.5.0"
  assert_success
  [ "$output" = "1.5.0" ]

  # Major.minor only (should add .0)
  run call_pgtle_function parse_version "1.5"
  assert_success
  [ "$output" = "1.5.0" ]

  # Multi-digit version
  run call_pgtle_function parse_version "10.2.3"
  assert_success
  [ "$output" = "10.2.3" ]
}

@test "pgtle: parse_version handles versions with suffixes" {
  # Alpha suffix
  run call_pgtle_function parse_version "1.5.0alpha1"
  assert_success
  [ "$output" = "1.5.0" ]

  # Beta suffix
  run call_pgtle_function parse_version "2.0beta"
  assert_success
  [ "$output" = "2.0.0" ]

  # Dev suffix
  run call_pgtle_function parse_version "1.2.3dev"
  assert_success
  [ "$output" = "1.2.3" ]
}

@test "pgtle: parse_version rejects invalid versions" {
  # Empty string
  run call_pgtle_function parse_version ""
  assert_failure
  assert_contains "Version string is empty"

  # Non-numeric
  run call_pgtle_function parse_version "latest"
  assert_failure
  assert_contains "Cannot parse version string"

  # Single number (need at least major.minor)
  run call_pgtle_function parse_version "5"
  assert_failure
  assert_contains "Invalid version format"
}

@test "pgtle: get_version_dir handles numeric versions" {
  # Version below 1.4.0
  run call_pgtle_function get_version_dir "1.3.0"
  assert_success
  [ "$output" = "pg_tle/1.0.0-1.4.0" ]

  # Version at 1.4.0
  run call_pgtle_function get_version_dir "1.4.0"
  assert_success
  [ "$output" = "pg_tle/1.4.0-1.5.0" ]

  # Version between 1.4.0 and 1.5.0
  run call_pgtle_function get_version_dir "1.4.5"
  assert_success
  [ "$output" = "pg_tle/1.4.0-1.5.0" ]

  # Version at 1.5.0
  run call_pgtle_function get_version_dir "1.5.0"
  assert_success
  [ "$output" = "pg_tle/1.5.0+" ]

  # Version above 1.5.0
  run call_pgtle_function get_version_dir "1.6.0"
  assert_success
  [ "$output" = "pg_tle/1.5.0+" ]
}

@test "pgtle: get_version_dir handles versions with suffixes" {
  # Alpha version below 1.4.0
  run call_pgtle_function get_version_dir "1.3.0alpha1"
  assert_success
  [ "$output" = "pg_tle/1.0.0-1.4.0" ]

  # Alpha version at 1.4.0 (alpha is before release, so < 1.4.0)
  run call_pgtle_function get_version_dir "1.4.0alpha1"
  assert_success
  [ "$output" = "pg_tle/1.0.0-1.4.0" ]

  # Alpha version at 1.5.0 (alpha is before release, so < 1.5.0)
  run call_pgtle_function get_version_dir "1.5.0alpha1"
  assert_success
  [ "$output" = "pg_tle/1.4.0-1.5.0" ]

  # Dev version above 1.5.0
  run call_pgtle_function get_version_dir "2.0dev"
  assert_success
  [ "$output" = "pg_tle/1.5.0+" ]
}

@test "pgtle: get_version_dir rejects invalid versions" {
  # Empty string
  run call_pgtle_function get_version_dir ""
  assert_failure
  assert_contains "Version required"

  # Non-numeric
  run call_pgtle_function get_version_dir "latest"
  assert_failure
  assert_contains "Cannot parse version string"
}

@test "pgtle: version_to_number rejects overflow" {
  # Major version overflow (>= 1000)
  run call_pgtle_function version_to_number "1000.0.0"
  assert_failure
  assert_contains "Major version too large"
  assert_contains "max 999"

  # Minor version overflow (>= 1000)
  run call_pgtle_function version_to_number "1.1000.0"
  assert_failure
  assert_contains "Minor version too large"
  assert_contains "max 999"

  # Patch version overflow (>= 1000)
  run call_pgtle_function version_to_number "1.5.1000"
  assert_failure
  assert_contains "Patch version too large"
  assert_contains "max 999"
}

@test "pgtle: version_to_number accepts maximum valid values" {
  # Max valid values (999.999.999)
  run call_pgtle_function version_to_number "999.999.999"
  assert_success
  [ "$output" = "999999999" ]

  # Edge case just below overflow
  run call_pgtle_function version_to_number "999.999.998"
  assert_success
  [ "$output" = "999999998" ]
}

@test "pgtle: get_version_dir propagates overflow errors" {
  # Version overflow should be caught and reported
  run call_pgtle_function get_version_dir "1000.0.0"
  assert_failure
  assert_contains "Major version too large"
}

# vi: expandtab sw=2 ts=2

